<?xml version="1.0"?>
<!--
  This file is licensed to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<class ns="net.sf.xmlunit.diff" qualifiers="public sealed"
       name="DOMDifferenceEngine"
       summary="Difference engine based on DOM."
       extends="AbstractDifferenceEngine">

  <import reference="System"/>
  <import reference="System.Collections.Generic"/>
  <import reference="System.Xml"/>
  <import reference="System.Xml.Schema"/>
  <import reference="net.sf.xmlunit.util"/>

  <literal><![CDATA[

        private static readonly object DUMMY = new object();

        public override void Compare(ISource control, ISource test) {
            if (control == null) {
                throw new ArgumentNullException("control");
            }
            if (test == null) {
                throw new ArgumentNullException("test");
            }

            CompareNodes(net.sf.xmlunit.util.Convert.ToNode(control),
                         net.sf.xmlunit.util.Convert.ToNode(test));
        }

        /// <summary>
        /// Recursively compares two XML nodes.
        /// </summary>
        /// <remarks>
        /// Performs comparisons common to all node types, the performs
        /// the node type specific comparisons and finally recures into
        /// the node's child lists.
        ///
        /// Stops as soon as any comparison returns ComparisonResult.CRITICAL.
        /// </remarks>
        internal ComparisonResult CompareNodes(XmlNode control, XmlNode test) {
]]></literal>
  <lastResultDef/>
  <compare type="NODE_TYPE" property="NodeType"/>
  <compare type="NAMESPACE_URI" property="NamespaceURI"/>
  <compare type="NAMESPACE_PREFIX" property="Prefix"/>
  <literal><![CDATA[
            XmlNodeList controlChildren = control.ChildNodes;
            XmlNodeList testChildren = test.ChildNodes;
]]></literal>
  <compareExpr type="CHILD_NODELIST_LENGTH"
               controlExpr="controlChildren.Count"
               testExpr="testChildren.Count"/>
  <compareMethod method="NodeTypeSpecificComparison"/>
  <literal><![CDATA[
            return CompareNodeLists(controlChildren, testChildren);
        }

        /// <summary>
        /// Dispatches to the node type specific comparison if one is
        /// defined for the given combination of nodes.
        /// </summary>
        private ComparisonResult NodeTypeSpecificComparison(XmlNode control,
                                                            XmlNode test) {
            switch (control.NodeType) {
            case XmlNodeType.CDATA:
            case XmlNodeType.Comment:
            case XmlNodeType.Text:
                if (test is XmlCharacterData) {
                    return CompareCharacterData((XmlCharacterData) control,
                                                (XmlCharacterData) test);
                }
                break;
            case XmlNodeType.Document:
                if (test is XmlDocument) {
                    return CompareDocuments((XmlDocument) control,
                                            (XmlDocument) test);
                }
                break;
            case XmlNodeType.Element:
                if (test is XmlElement) {
                    return CompareElements((XmlElement) control,
                                           (XmlElement) test);
                }
                break;
            case XmlNodeType.ProcessingInstruction:
                if (test is XmlProcessingInstruction) {
                    return
                        CompareProcessingInstructions((XmlProcessingInstruction) control,
                                                      (XmlProcessingInstruction) test);
                }
                break;
            case XmlNodeType.DocumentType:
                if (test is XmlDocumentType) {
                    return CompareDocTypes((XmlDocumentType) control,
                                           (XmlDocumentType) test);
                }
                break;
            case XmlNodeType.Attribute:
                if (test is XmlAttribute) {
                    return CompareAttributes((XmlAttribute) control,
                                             (XmlAttribute) test);
                }
                break;
            }
            return ComparisonResult.EQUAL;
        }

        /// <summary>
        /// Compares textual content.
        /// </summary>
        private ComparisonResult CompareCharacterData(XmlCharacterData control,
                                                      XmlCharacterData test) {
            return Compare(new Comparison(ComparisonType.TEXT_VALUE, control,
                                          null, control.Data,
                                          test, null, test.Data));
        }

        private ComparisonResult CompareDocuments(XmlDocument control,
                                                  XmlDocument test) {
            XmlDocumentType controlDt = control.DocumentType;
            XmlDocumentType testDt = test.DocumentType;
]]></literal>
  <lastResultDef/>
  <compareExpr type="HAS_DOCTYPE_DECLARATION"
               controlExpr="controlDt != null"
               testExpr="testDt != null"/>
  <literal><![CDATA[
            if (controlDt != null && testDt != null) {
]]></literal>
  <compareMethodExpr method="CompareNodes"
                     controlExpr="controlDt"
                     testExpr="testDt"/>
  <literal><![CDATA[
            }
            XmlDeclaration controlDecl = control.FirstChild as XmlDeclaration;
            XmlDeclaration testDecl = test.FirstChild as XmlDeclaration;
]]></literal>
  <compareMethodExpr method="CompareDeclarations"
                     controlExpr="controlDecl"
                     testExpr="testDecl"/>
  <literal><![CDATA[
            return lastResult;
        }

        private ComparisonResult CompareDocTypes(XmlDocumentType control,
                                                 XmlDocumentType test) {
]]></literal>
  <lastResultDef/>
  <compare type="DOCTYPE_NAME" property="Name"/>
  <compare type="DOCTYPE_PUBLIC_ID" property="PublicId"/>
  <literal><![CDATA[
            return Compare(new Comparison(ComparisonType.DOCTYPE_SYSTEM_ID,
                                          control, null, control.SystemId,
                                          test, null, test.SystemId));
        }

        private ComparisonResult CompareDeclarations(XmlDeclaration control,
                                                     XmlDeclaration test) {
]]></literal>
  <lastResultDef/>
  <literal><![CDATA[
            string controlVersion =
                control == null ? "1.0" : control.Version;
            string testVersion =
                test == null ? "1.0" : test.Version;
]]></literal>
  <compareExpr type="XML_VERSION"
               controlExpr="controlVersion"
               testExpr="testVersion"/>
  <literal><![CDATA[
            string controlStandalone =
                control == null ? string.Empty : control.Standalone;
            string testStandalone =
                test == null ? string.Empty : test.Standalone;
]]></literal>
  <compareExpr type="XML_STANDALONE"
               controlExpr="controlStandalone"
               testExpr="testStandalone"/>
  <literal><![CDATA[
            string controlEncoding =
                control != null ? control.Encoding : string.Empty;
            string testEncoding = test != null ? test.Encoding : string.Empty;
            return Compare(new Comparison(ComparisonType.XML_ENCODING,
                                          control, null, controlEncoding,
                                          test, null, testEncoding));
        }

        private ComparisonResult CompareElements(XmlElement control,
                                                 XmlElement test) {
]]></literal>
  <lastResultDef/>
  <compare type="ELEMENT_TAG_NAME" property="Name"/>
  <literal><![CDATA[
            Attributes controlAttributes = SplitAttributes(control.Attributes);
            Attributes testAttributes = SplitAttributes(test.Attributes);
            IDictionary<XmlAttribute, object> foundTestAttributes =
                new Dictionary<XmlAttribute, object>();
]]></literal>
  <compareExpr type="ELEMENT_NUM_ATTRIBUTES"
               controlExpr="controlAttributes.RemainingAttributes.Count"
               testExpr="testAttributes.RemainingAttributes.Count"/>
  <literal><![CDATA[
            foreach (XmlAttribute controlAttr in controlAttributes.RemainingAttributes) {
                XmlAttribute testAttr =
                    FindMatchingAttr(testAttributes.RemainingAttributes,
                                     controlAttr);
]]></literal>
  <compareExpr type="ATTR_NAME_LOOKUP"
               controlExpr="true"
               testExpr="testAttr != null"/>
  <literal><![CDATA[
                if (testAttr != null) {
]]></literal>
  <compareMethodExpr method="CompareNodes"
                     controlExpr="controlAttr"
                     testExpr="testAttr"/>
  <literal><![CDATA[
                    foundTestAttributes[testAttr] = DUMMY;
                }
            }
]]></literal>
  <literal><![CDATA[
            foreach (XmlAttribute testAttr in testAttributes.RemainingAttributes) {
]]></literal>
  <compareExpr type="ATTR_NAME_LOOKUP"
               controlExpr="foundTestAttributes.ContainsKey(testAttr)"
               testExpr="true"/>
  <literal><![CDATA[
            }
]]></literal>
  <compareExpr type="SCHEMA_LOCATION"
               controlExpr="controlAttributes.SchemaLocation != null ? controlAttributes.SchemaLocation.Value : null"
               testExpr="testAttributes.SchemaLocation != null ? testAttributes.SchemaLocation.Value : null"
               />
  <compareExpr type="NO_NAMESPACE_SCHEMA_LOCATION"
               controlExpr="controlAttributes.NoNamespaceSchemaLocation != null ? controlAttributes.NoNamespaceSchemaLocation.Value : null"
               testExpr="testAttributes.NoNamespaceSchemaLocation != null ? testAttributes.NoNamespaceSchemaLocation.Value : null"
               />
  <literal><![CDATA[
            return lastResult;
        }

        private ComparisonResult
            CompareProcessingInstructions(XmlProcessingInstruction control,
                                          XmlProcessingInstruction test) {
]]></literal>
  <lastResultDef/>
  <compare type="PROCESSING_INSTRUCTION_TARGET" property="Target"/>
  <literal><![CDATA[
            return Compare(new Comparison(ComparisonType.PROCESSING_INSTRUCTION_DATA,
                                          control, null, control.Data,
                                          test, null, test.Data));
        }

        private ComparisonResult CompareNodeLists(XmlNodeList control,
                                                  XmlNodeList test) {
            IList<XmlNode> controlList =
                new List<XmlNode>(Linqy.Cast<XmlNode>(control));
            IList<XmlNode> testList =
                new List<XmlNode>(Linqy.Cast<XmlNode>(test));
            IDictionary<int, object> unmatchedTestIndexes =
                new SortedDictionary<int, object>();
            for (int i = 0; i < testList.Count; i++) {
                unmatchedTestIndexes.Add(i, DUMMY);
            }
]]></literal>
  <lastResultDef/>
  <literal><![CDATA[
            // if there are no children on either Node, the result is equal
            lastResult = ComparisonResult.EQUAL;
            Match lastMatch = new Match(null, -1);
            for (int i = 0; i < controlList.Count; i++) {
                Match testMatch = FindMatchingNode(controlList[i], testList,
                                                   lastMatch.Index);
                if (testMatch != null) {
]]></literal>
  <compareMethodExpr method="CompareNodes"
                     controlExpr="controlList[i]"
                     testExpr="testMatch.Node"/>
  <literal><![CDATA[
                    unmatchedTestIndexes.Remove(testMatch.Index);
                    lastMatch = testMatch;
                } else {
                    lastResult =
                        Compare(new Comparison(ComparisonType.CHILD_LOOKUP,
                                               controlList[i], null,
                                               controlList[i],
                                               null, null, null));
]]></literal>
 <if-return-boilerplate/>
 <literal><![CDATA[
                }
            }
            foreach (int i in unmatchedTestIndexes.Keys) {
                lastResult =
                    Compare(new Comparison(ComparisonType.CHILD_LOOKUP,
                                           null, null, null,
                                           testList[i], null, testList[i]));
]]></literal>
  <if-return-boilerplate/>
  <literal><![CDATA[
            }
            return lastResult;
        }

        private ComparisonResult CompareAttributes(XmlAttribute control,
                                                   XmlAttribute test) {
]]></literal>
  <lastResultDef/>
  <compare type="ATTR_VALUE_EXPLICITLY_SPECIFIED" property="Specified"/>
  <literal><![CDATA[
            return Compare(new Comparison(ComparisonType.ATTR_VALUE,
                                          control, null, control.Value,
                                          test, null, test.Value));
        }

        private static Attributes SplitAttributes(XmlAttributeCollection map) {
            XmlAttribute sLoc = map.GetNamedItem("schemaLocation",
                                                 XmlSchema.InstanceNamespace)
                as XmlAttribute;
            XmlAttribute nNsLoc = map.GetNamedItem("noNamespaceSchemaLocation",
                                                   XmlSchema.InstanceNamespace)
                as XmlAttribute;
            List<XmlAttribute> rest = new List<XmlAttribute>();
            foreach (XmlAttribute a in map) {
                if (XmlSchema.InstanceNamespace != a.NamespaceURI
                    &&
                    "http://www.w3.org/2000/xmlns/" != a.NamespaceURI) {
                    rest.Add(a);
                }
            }
            return new Attributes(sLoc, nNsLoc, rest);
        }

        internal class Attributes {
            internal readonly XmlAttribute SchemaLocation;
            internal readonly XmlAttribute NoNamespaceSchemaLocation;
            internal readonly IList<XmlAttribute> RemainingAttributes;
            internal Attributes(XmlAttribute schemaLocation,
                               XmlAttribute noNamespaceSchemaLocation,
                               IList<XmlAttribute> remainingAttributes) {
                this.SchemaLocation = schemaLocation;
                this.NoNamespaceSchemaLocation = noNamespaceSchemaLocation;
                this.RemainingAttributes = remainingAttributes;
            }
        }

        private static XmlAttribute FindMatchingAttr(IList<XmlAttribute> attrs,
                                                     XmlAttribute attrToMatch) {
            bool hasNs = !string.IsNullOrEmpty(attrToMatch.NamespaceURI);
            string nsToMatch = attrToMatch.NamespaceURI;
            string nameToMatch = hasNs ? attrToMatch.LocalName
                : attrToMatch.Name;
            foreach (XmlAttribute a in attrs) {
                if (((!hasNs && string.IsNullOrEmpty(a.NamespaceURI))
                     ||
                     (hasNs && nsToMatch == a.NamespaceURI))
                    &&
                    ((hasNs && nameToMatch == a.LocalName)
                     ||
                     (!hasNs && nameToMatch == a.Name))
                   ) {
                    return a;
                }
            }
            return null;
        }

        private Match FindMatchingNode(XmlNode searchFor,
                                       IList<XmlNode> searchIn,
                                       int indexOfLastMatch) {
            int searchSize = searchIn.Count;
            for (int i = indexOfLastMatch + 1; i < searchSize; i++) {
                if (NodesMatch(searchFor, searchIn[i])) {
                    return new Match(searchIn[i], i);
                }
            }
            for (int i = 0; i < indexOfLastMatch; i++) {
                if (NodesMatch(searchFor, searchIn[i])) {
                    return new Match(searchIn[i], i);
                }
            }
            return null;
        }

        private bool NodesMatch(XmlNode n1, XmlNode n2) {
            if (n1 is XmlElement && n2 is XmlElement) {
                return ElementSelector(n1 as XmlElement, n2 as XmlElement);
            }
            ComparisonResult r =
                Compare(new Comparison(ComparisonType.NODE_TYPE,
                                       n1, null, n1.NodeType,
                                       n2, null, n2.NodeType));
            return r != ComparisonResult.CRITICAL;
        }

        internal class Match {
            internal readonly XmlNode Node;
            internal readonly int Index;
            internal Match(XmlNode match, int index) {
                Node = match;
                Index = index;
            }
        }
]]></literal>
</class>