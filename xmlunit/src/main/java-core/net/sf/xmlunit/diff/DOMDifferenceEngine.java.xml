<?xml version="1.0"?>
<!--
  This file is licensed to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<class ns="net.sf.xmlunit.diff" qualifiers="public final"
       name="DOMDifferenceEngine"
       summary="Difference engine based on DOM."
       extends="AbstractDifferenceEngine">

  <import reference="java.util.HashSet"/>
  <import reference="java.util.LinkedList"/>
  <import reference="java.util.List"/>
  <import reference="java.util.Set"/>
  <import reference="java.util.TreeSet"/>
  <import reference="javax.xml.XMLConstants"/>
  <import reference="javax.xml.namespace.QName"/>
  <import reference="javax.xml.transform.Source"/>
  <import reference="net.sf.xmlunit.util.Convert"/>
  <import reference="net.sf.xmlunit.util.IterableNodeList"/>
  <import reference="net.sf.xmlunit.util.Linqy"/>
  <import reference="net.sf.xmlunit.util.Nodes"/>
  <import reference="org.w3c.dom.Attr"/>
  <import reference="org.w3c.dom.CharacterData"/>
  <import reference="org.w3c.dom.Document"/>
  <import reference="org.w3c.dom.DocumentType"/>
  <import reference="org.w3c.dom.Element"/>
  <import reference="org.w3c.dom.NamedNodeMap"/>
  <import reference="org.w3c.dom.Node"/>
  <import reference="org.w3c.dom.NodeList"/>
  <import reference="org.w3c.dom.ProcessingInstruction"/>

  <literal><![CDATA[
    public void compare(Source control, Source test) {
        if (control == null) {
            throw new IllegalArgumentException("control must not be null");
        }
        if (test == null) {
            throw new IllegalArgumentException("test must not be null");
        }
        compareNodes(Convert.toNode(control), new XPathContext(),
                     Convert.toNode(test), new XPathContext());
    }

    /**
     * Recursively compares two XML nodes.
     *
     * <p>Performs comparisons common to all node types, the performs
     * the node type specific comparisons and finally recures into
     * the node's child lists.</p>
     *
     * <p>Stops as soon as any comparison returns
     * ComparisonResult.CRITICAL.</p>
     *
     * <p>package private to support tests.</p>
     */
    ComparisonResult compareNodes(Node control, XPathContext controlContext,
                                  Node test, XPathContext testContext) {
]]></literal>
  <lastResultDef/>
  <compare type="NODE_TYPE" property="getNodeType()"/>
  <compare type="NAMESPACE_URI" property="getNamespaceURI()"/>
  <compare type="NAMESPACE_PREFIX" property="getPrefix()"/>
  <literal><![CDATA[
        NodeList controlChildren = control.getChildNodes();
        NodeList testChildren = test.getChildNodes();
        if (control.getNodeType() != Node.ATTRIBUTE_NODE) {
]]></literal>
  <compareExpr type="CHILD_NODELIST_LENGTH"
               controlExpr="controlChildren.getLength()"
               testExpr="testChildren.getLength()"/>
  <literal><![CDATA[
         }
]]></literal>
  <compareMethod method="nodeTypeSpecificComparison"/>
  <literal><![CDATA[
        if (control.getNodeType() != Node.ATTRIBUTE_NODE) {
            controlContext
                .setChildren(Linqy.map(new IterableNodeList(controlChildren),
                                       TO_NODE_INFO));
            testContext
                .setChildren(Linqy.map(new IterableNodeList(testChildren),
                                       TO_NODE_INFO));
]]></literal>
  <compareMethodExpr method="compareNodeLists"
                     controlExpr="controlChildren"
                     testExpr="testChildren"/>
  <literal><![CDATA[
        }
        return lastResult;
    }

    /**
     * Dispatches to the node type specific comparison if one is
     * defined for the given combination of nodes.
     *
     * <p>package private to support tests.</p>
     */
    private ComparisonResult nodeTypeSpecificComparison(Node control,
                                                        XPathContext controlContext,
                                                        Node test,
                                                        XPathContext testContext) {
        switch (control.getNodeType()) {
        case Node.CDATA_SECTION_NODE:
        case Node.COMMENT_NODE:
        case Node.TEXT_NODE:
            if (test instanceof CharacterData) {
                return compareCharacterData((CharacterData) control,
                                            controlContext,
                                            (CharacterData) test, testContext);
            }
            break;
        case Node.DOCUMENT_NODE:
            if (test instanceof Document) {
                return compareDocuments((Document) control, controlContext,
                                        (Document) test, testContext);
            }
            break;
        case Node.ELEMENT_NODE:
            if (test instanceof Element) {
                return compareElements((Element) control, controlContext,
                                       (Element) test, testContext);
            }
            break;
        case Node.PROCESSING_INSTRUCTION_NODE:
            if (test instanceof ProcessingInstruction) {
                return
                    compareProcessingInstructions((ProcessingInstruction) control,
                                                  controlContext,
                                                  (ProcessingInstruction) test,
                                                  testContext);
            }
            break;
        case Node.DOCUMENT_TYPE_NODE:
            if (test instanceof DocumentType) {
                return compareDocTypes((DocumentType) control, controlContext,
                                       (DocumentType) test, testContext);
            }
            break;
        case Node.ATTRIBUTE_NODE:
            if (test instanceof Attr) {
                return compareAttributes((Attr) control, controlContext,
                                         (Attr) test, testContext);
            }
            break;
        }
        return ComparisonResult.EQUAL;
    }

    /**
     * Compares textual content.
     */
    private ComparisonResult compareCharacterData(CharacterData control,
                                                  XPathContext controlContext,
                                                  CharacterData test,
                                                  XPathContext testContext) {
        return compare(new Comparison(ComparisonType.TEXT_VALUE, control,
                                      getXPath(controlContext),
                                      control.getData(),
                                      test, getXPath(testContext),
                                      test.getData()));
    }

    private ComparisonResult compareDocuments(Document control,
                                              XPathContext controlContext,
                                              Document test,
                                              XPathContext testContext) {
        DocumentType controlDt = control.getDoctype();
        DocumentType testDt = test.getDoctype();
]]></literal>
  <lastResultDef/>
  <compareExpr type="HAS_DOCTYPE_DECLARATION"
               controlExpr="Boolean.valueOf(controlDt != null)"
               testExpr="Boolean.valueOf(testDt != null)"/>
  <literal><![CDATA[
        if (controlDt != null && testDt != null) {
]]></literal>
  <compareMethodExpr method="compareNodes"
                     controlExpr="controlDt"
                     testExpr="testDt"/>
  <literal><![CDATA[
        }
]]></literal>
  <compare type="XML_VERSION" property="getXmlVersion()"/>
  <compare type="XML_STANDALONE" property="getXmlStandalone()"/>
  <literal><![CDATA[
        return compare(new Comparison(ComparisonType.XML_ENCODING,
                                      control, getXPath(controlContext),
                                      control.getXmlEncoding(),
                                      test, getXPath(testContext),
                                      test.getXmlEncoding()));
    }

    private ComparisonResult compareDocTypes(DocumentType control,
                                             XPathContext controlContext,
                                             DocumentType test,
                                             XPathContext testContext) {
]]></literal>
  <lastResultDef/>
  <compare type="DOCTYPE_NAME" property="getName()"/>
  <compare type="DOCTYPE_PUBLIC_ID" property="getPublicId()"/>
  <literal><![CDATA[
        return compare(new Comparison(ComparisonType.DOCTYPE_SYSTEM_ID,
                                      control, null, control.getSystemId(),
                                      test, null, test.getSystemId()));
    }

    private ComparisonResult compareElements(Element control,
                                             XPathContext controlContext,
                                             Element test,
                                             XPathContext testContext) {
]]></literal>
  <lastResultDef/>
  <compareExpr type="ELEMENT_TAG_NAME"
               controlExpr="Nodes.getQName(control).getLocalPart()"
               testExpr="Nodes.getQName(test).getLocalPart()"/>
  <literal><![CDATA[
        Attributes controlAttributes = splitAttributes(control.getAttributes());
        controlContext
            .addAttributes(Linqy.map(controlAttributes.remainingAttributes,
                                     QNAME_MAPPER));
        Attributes testAttributes = splitAttributes(test.getAttributes());
        testContext
            .addAttributes(Linqy.map(testAttributes.remainingAttributes,
                                     QNAME_MAPPER));
        Set<Attr> foundTestAttributes = new HashSet<Attr>();
]]></literal>
  <compareExpr type="ELEMENT_NUM_ATTRIBUTES"
               controlExpr="controlAttributes.remainingAttributes.size()"
               testExpr="testAttributes.remainingAttributes.size()"/>
  <literal><![CDATA[
        for (Attr controlAttr : controlAttributes.remainingAttributes) {
            final Attr testAttr =
                findMatchingAttr(testAttributes.remainingAttributes,
                                 controlAttr);
]]></literal>
            controlContext.navigateToAttribute(Nodes.getQName(controlAttr));
            try {
  <compareExpr type="ATTR_NAME_LOOKUP"
               controlExpr="Boolean.TRUE"
               testExpr="Boolean.valueOf(testAttr != null)"/>
  <literal><![CDATA[
                if (testAttr != null) {
                    testContext.navigateToAttribute(Nodes.getQName(testAttr));
                    try {
]]></literal>
  <compareMethodExpr method="compareNodes"
                     controlExpr="controlAttr"
                     testExpr="testAttr"/>
  <literal><![CDATA[
                        foundTestAttributes.add(testAttr);
                    } finally {
                        testContext.navigateToParent();
                    }
                }
            } finally {
                controlContext.navigateToParent();
            }
        }
]]></literal>
  <literal><![CDATA[
        for (Attr testAttr : testAttributes.remainingAttributes) {
            testContext.navigateToAttribute(Nodes.getQName(testAttr));
            try {
]]></literal>
  <compareExpr type="ATTR_NAME_LOOKUP"
               controlExpr="Boolean.valueOf(foundTestAttributes.contains(testAttr))"
               testExpr="Boolean.TRUE"/>
  <literal><![CDATA[
            } finally {
                testContext.navigateToParent();
            }
        }
]]></literal>
  <compareExpr type="SCHEMA_LOCATION"
               controlExpr="controlAttributes.schemaLocation != null ? controlAttributes.schemaLocation.getValue() : null"
               testExpr="testAttributes.schemaLocation != null ? testAttributes.schemaLocation.getValue() : null"
               />
  <compareExpr type="NO_NAMESPACE_SCHEMA_LOCATION"
               controlExpr="controlAttributes.noNamespaceSchemaLocation != null ? controlAttributes.noNamespaceSchemaLocation.getValue() : null"
               testExpr="testAttributes.noNamespaceSchemaLocation != null ? testAttributes.noNamespaceSchemaLocation.getValue() : null"
               />
  <literal><![CDATA[
        return lastResult;
    }

    private ComparisonResult
        compareProcessingInstructions(ProcessingInstruction control,
                                      XPathContext controlContext,
                                      ProcessingInstruction test,
                                      XPathContext testContext) {
]]></literal>
  <lastResultDef/>
  <compare type="PROCESSING_INSTRUCTION_TARGET" property="getTarget()"/>
  <literal><![CDATA[
        return compare(new Comparison(ComparisonType.PROCESSING_INSTRUCTION_DATA,
                                      control, getXPath(controlContext),
                                      control.getData(),
                                      test, getXPath(testContext),
                                      test.getData()));
    }

    private ComparisonResult compareNodeLists(NodeList control,
                                              XPathContext controlContext,
                                              NodeList test,
                                              XPathContext testContext) {
        List<Node> controlList = IterableNodeList.asList(control);
        List<Node> testList = IterableNodeList.asList(test);
        final int testSize = testList.size();
        Set<Integer> unmatchedTestIndexes = new TreeSet<Integer>();
        for (int i = 0; i < testSize; i++) {
            unmatchedTestIndexes.add(Integer.valueOf(i));
        }
]]></literal>
  <lastResultDef/>
  <literal><![CDATA[
        // if there are no children on either Node, the result is equal
        lastResult = ComparisonResult.EQUAL;
        final int controlSize = controlList.size();
        Match lastMatch = new Match(null, -1);
        for (int i = 0; i < controlSize; i++) {
            controlContext.navigateToChild(i);
            try {
                Match testMatch = findMatchingNode(controlList.get(i), testList,
                                                   lastMatch.index);
                if (testMatch != null) {
]]></literal>
                    testContext.navigateToChild(testMatch.index);
                    try {
                        Integer testIndex = Integer.valueOf(testMatch.index);
  <compareExpr type="CHILD_NODELIST_SEQUENCE"
               controlExpr="Integer.valueOf(i)"
               testExpr="testIndex"
               />
  <compareMethodExpr method="compareNodes"
                     controlExpr="controlList.get(i)"
                     testExpr="testMatch.node"/>
  <literal><![CDATA[
                        unmatchedTestIndexes.remove(testIndex);
                        lastMatch = testMatch;
                    } finally {
                        testContext.navigateToParent();
                    }
                } else {
                    lastResult =
                        compare(new Comparison(ComparisonType.CHILD_LOOKUP,
                                               controlList.get(i),
                                               getXPath(controlContext),
                                               controlList.get(i),
                                               null, null, null));
]]></literal>
  <if-return-boilerplate/>
  <literal><![CDATA[
                }
            } finally {
                controlContext.navigateToParent();
            }
        }
        for (Integer I : unmatchedTestIndexes) {
            int i = I.intValue();
            testContext.navigateToChild(i);
            try {
                lastResult =
                    compare(new Comparison(ComparisonType.CHILD_LOOKUP,
                                           null, null, null,
                                           testList.get(i),
                                           getXPath(testContext),
                                           testList.get(i)));
]]></literal>
  <if-return-boilerplate/>
  <literal><![CDATA[
            } finally {
                testContext.navigateToParent();
            }
        }
        return lastResult;
    }

    private ComparisonResult compareAttributes(Attr control,
                                               XPathContext controlContext,
                                               Attr test,
                                               XPathContext testContext) {
]]></literal>
  <lastResultDef/>
  <compare type="ATTR_VALUE_EXPLICITLY_SPECIFIED" property="getSpecified()"/>
  <literal><![CDATA[
        return compare(new Comparison(ComparisonType.ATTR_VALUE,
                                      control, getXPath(controlContext),
                                      control.getValue(),
                                      test, getXPath(testContext),
                                      test.getValue()));
    }

    private static Attributes splitAttributes(final NamedNodeMap map) {
        Attr sLoc = (Attr) map.getNamedItemNS(XMLConstants
                                              .W3C_XML_SCHEMA_INSTANCE_NS_URI,
                                              "schemaLocation");
        Attr nNsLoc = (Attr) map.getNamedItemNS(XMLConstants
                                                .W3C_XML_SCHEMA_INSTANCE_NS_URI,
                                                "noNamespaceSchemaLocation");
        List<Attr> rest = new LinkedList<Attr>();
        final int len = map.getLength();
        for (int i = 0; i < len; i++) {
            Attr a = (Attr) map.item(i);
            if (!XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(a.getNamespaceURI())
                &&
               !XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI
                 .equals(a.getNamespaceURI())) {
                rest.add(a);
            }
        }
        return new Attributes(sLoc, nNsLoc, rest);
    }

    private static class Attributes {
        private final Attr schemaLocation;
        private final Attr noNamespaceSchemaLocation;
        private final List<Attr> remainingAttributes;
        private Attributes(Attr schemaLocation, Attr noNamespaceSchemaLocation,
                           List<Attr> remainingAttributes) {
            this.schemaLocation = schemaLocation;
            this.noNamespaceSchemaLocation = noNamespaceSchemaLocation;
            this.remainingAttributes = remainingAttributes;
        }
    }

    private static Attr findMatchingAttr(final List<Attr> attrs,
                                         final Attr attrToMatch) {
        final boolean hasNs = attrToMatch.getNamespaceURI() != null;
        final String nsToMatch = attrToMatch.getNamespaceURI();
        final String nameToMatch = hasNs ? attrToMatch.getLocalName()
            : attrToMatch.getName();
        for (Attr a : attrs) {
            if (((!hasNs && a.getNamespaceURI() == null)
                 ||
                 (hasNs && nsToMatch.equals(a.getNamespaceURI())))
                &&
                ((hasNs && nameToMatch.equals(a.getLocalName()))
                 ||
                 (!hasNs && nameToMatch.equals(a.getName())))
               ) {
                return a;
            }
        }
        return null;
    }

    private Match findMatchingNode(final Node searchFor,
                                   final List<Node> searchIn,
                                   final int indexOfLastMatch) {
        final int searchSize = searchIn.size();
        for (int i = indexOfLastMatch + 1; i < searchSize; i++) {
            if (nodesMatch(searchFor, searchIn.get(i))) {
                return new Match(searchIn.get(i), i);
            }
        }
        for (int i = 0; i < indexOfLastMatch; i++) {
            if (nodesMatch(searchFor, searchIn.get(i))) {
                return new Match(searchIn.get(i), i);
            }
        }
        return null;
    }

    private boolean nodesMatch(final Node n1, final Node n2) {
        if (n1 instanceof Element && n2 instanceof Element) {
            return getElementSelector()
                .canBeCompared((Element) n1, (Element) n2);
        }
        ComparisonResult r =
            compare(new Comparison(ComparisonType.NODE_TYPE,
                                   n1, null, n1.getNodeType(),
                                   n2, null, n2.getNodeType()));
        return r != ComparisonResult.CRITICAL;
    }

    private class Match {
        private final Node node;
        private final int index;
        private Match(Node match, int index) {
            this.node = match;
            this.index = index;
        }
    }

    private static final Linqy.Mapper<Node, QName> QNAME_MAPPER =
        new Linqy.Mapper<Node, QName>() {
            public QName map(Node n) { return Nodes.getQName(n); }
        };

    private static final Linqy.Mapper<Node, XPathContext.NodeInfo> TO_NODE_INFO =
        new Linqy.Mapper<Node, XPathContext.NodeInfo>() {
            public XPathContext.NodeInfo map(Node n) {
                return new XPathContext.DOMNodeInfo(n);
            }
        };
]]></literal>
</class>